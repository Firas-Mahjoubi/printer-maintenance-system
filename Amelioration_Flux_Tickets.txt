# Amélioration du flux des tickets de maintenance

## Étapes du cycle de vie d'un ticket

### 1. Création du ticket
- **Client ou Technicien**: Création initiale avec informations de base (titre, description, priorité)
- **Statut**: EN_ATTENTE
- **Champs obligatoires**: titre, description, priorité, imprimante(s) concernée(s)
- **Champs optionnels**: dateDemande (date souhaitée par le client)

### 2. Triage et planification
- **Rôle**: Gestionnaire/Administrateur
- **Action**: Assignation d'un technicien et planification d'une date d'intervention
- **Statut**: PLANIFIEE
- **Champs à compléter**: technicien, datePlanifiee, coutEstime (si applicable)

### 3. Début d'intervention
- **Rôle**: Technicien
- **Action**: Commencer l'intervention
- **Statut**: EN_COURS
- **Champs à compléter**: dateDebutIntervention (automatique)
- **Remarque**: Possibilité de mettre en pause et reprendre si nécessaire

### 4. Diagnostic technique
- **Rôle**: Technicien
- **Action**: Enregistrer le diagnostic après examen
- **Statut**: EN_COURS
- **Champs à compléter**: diagnosticTechnique, symptomes (détaillés)

### 5. Résolution
- **Rôle**: Technicien
- **Action**: Résoudre le problème et enregistrer la solution
- **Statut**: EN_COURS → TERMINEE
- **Champs à compléter**: 
  - solutionAppliquee
  - piecesUtilisees
  - coutReel
  - observations
  - dateFinIntervention (automatique)

### 6. Clôture et satisfaction
- **Rôle**: Client
- **Action**: Valider l'intervention et soumettre une évaluation
- **Statut**: TERMINEE → CLOTUREE
- **Champs à compléter**: 
  - noteSatisfaction
  - commentaireClient
  - dateCloture (automatique)

## Améliorations spécifiques à apporter

1. **Validation des étapes**: S'assurer que les étapes sont suivies dans l'ordre logique
2. **Champs obligatoires par étape**: Définir quels champs doivent être remplis à chaque étape
3. **Notification automatique**: Notifier les parties concernées à chaque changement d'étape
4. **Interface spécifique par rôle**: Adapter l'interface en fonction du rôle de l'utilisateur
5. **Historique détaillé**: Enregistrer chaque action et modification dans l'historique
6. **Gestion des coûts**: Permettre d'ajouter/modifier les coûts estimés et réels
7. **Documentation technique**: Faciliter l'ajout de documentation technique détaillée

## Workflows spécifiques à implémenter

### Pour les techniciens:
- Interface de diagnostic avec possibilité d'ajouter des photos
- Liste de solutions courantes à sélectionner
- Catalogue de pièces détachées avec coûts associés
- Formulaire de rapport d'intervention structuré

### Pour les clients:
- Suivi en temps réel de l'état de leurs tickets
- Notification des changements importants (planification, début, fin)
- Formulaire d'évaluation simple et intuitif
- Historique des interventions passées

## Correction: Autoriser les administrateurs à terminer les tickets

### Problème initial
Lors de la tentative de terminer une intervention par un administrateur, le message d'erreur suivant apparaît:
"Vous n'avez pas les permissions nécessaires pour terminer cette intervention. Seul le technicien assigné peut effectuer cette action."

### Solution implémentée
Modification du `InterventionService.java` pour permettre aux administrateurs de terminer et clôturer les tickets, pas seulement aux techniciens assignés.

#### Changements dans la méthode `terminerIntervention`
Remplacement de:
```java
if (intervention.getTechnicien() == null || intervention.getTechnicien().getId() != technicienId) {
    throw new RuntimeException("Seul le technicien assigné peut terminer cette intervention");
}
```

Par:
```java
// Récupérer l'utilisateur qui effectue l'action
Utilisateur utilisateur = utilisateurRepositorie.findById(technicienId)
    .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé"));

// Autoriser si c'est un admin ou le technicien assigné
boolean isAdmin = utilisateur.getRole() == Role.ADMIN;
boolean isAssignedTechnician = intervention.getTechnicien() != null && 
                              intervention.getTechnicien().getId() == technicienId;

if (!isAdmin && !isAssignedTechnician) {
    throw new RuntimeException("Seul le technicien assigné ou un administrateur peut terminer cette intervention");
}
```

#### Ajout dans la méthode `cloturerIntervention` (qui n'avait pas de vérification de permission)
```java
// Récupérer l'utilisateur qui effectue l'action
Utilisateur utilisateur = utilisateurRepositorie.findById(technicienId)
    .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé"));

// Autoriser si c'est un admin ou le technicien assigné
boolean isAdmin = utilisateur.getRole() == Role.ADMIN;
boolean isAssignedTechnician = intervention.getTechnicien() != null && 
                              intervention.getTechnicien().getId() == technicienId;

if (!isAdmin && !isAssignedTechnician) {
    throw new RuntimeException("Seul le technicien assigné ou un administrateur peut clôturer cette intervention");
}
```

#### Ajout de l'import nécessaire
```java
import com.example.maintenanceapp.Entity.Enum.Role;
```

### Résultat attendu
Après ces modifications, les administrateurs pourront terminer et clôturer les tickets d'intervention, même s'ils ne sont pas les techniciens assignés à ces tickets.
